(window.webpackJsonp=window.webpackJsonp||[]).push([[564],{839:function(t,a,s){"use strict";s.r(a);var i=s(14),n=Object(i.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[a("a",{attrs:{href:"https://codefun2000.com/p/P1738",target:"_blank",rel:"noopener noreferrer"}},[t._v("在线评测链接:P1738"),a("OutboundLink")],1)]),t._v(" "),a("h2",{attrs:{id:"题目描述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#题目描述"}},[t._v("#")]),t._v(" 题目描述")]),t._v(" "),a("p",[t._v("快递站共有"),a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",[a("semantics",[a("mrow",[a("mi",[t._v("n")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("n")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"strut",staticStyle:{height:"0.43056em"}}),a("span",{staticClass:"strut bottom",staticStyle:{height:"0.43056em","vertical-align":"0em"}}),a("span",{staticClass:"base textstyle uncramped"},[a("span",{staticClass:"mord mathit"},[t._v("n")])])])]),t._v("个快递点，"),a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",[a("semantics",[a("mrow",[a("mi",[t._v("n")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("n")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"strut",staticStyle:{height:"0.43056em"}}),a("span",{staticClass:"strut bottom",staticStyle:{height:"0.43056em","vertical-align":"0em"}}),a("span",{staticClass:"base textstyle uncramped"},[a("span",{staticClass:"mord mathit"},[t._v("n")])])])]),t._v("个快递点之间通过"),a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",[a("semantics",[a("mrow",[a("mi",[t._v("m")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("m")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"strut",staticStyle:{height:"0.43056em"}}),a("span",{staticClass:"strut bottom",staticStyle:{height:"0.43056em","vertical-align":"0em"}}),a("span",{staticClass:"base textstyle uncramped"},[a("span",{staticClass:"mord mathit"},[t._v("m")])])])]),t._v("条个快递站单向车道连接，快递员从任何一个快递站点出发，都无法通过单向车道回到该站点。也就是说，"),a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",[a("semantics",[a("mrow",[a("mi",[t._v("n")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("n")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"strut",staticStyle:{height:"0.43056em"}}),a("span",{staticClass:"strut bottom",staticStyle:{height:"0.43056em","vertical-align":"0em"}}),a("span",{staticClass:"base textstyle uncramped"},[a("span",{staticClass:"mord mathit"},[t._v("n")])])])]),t._v("个快递点组成一张有向无环图。对于快递点"),a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",[a("semantics",[a("mrow",[a("mi",[t._v("u")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("u")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"strut",staticStyle:{height:"0.43056em"}}),a("span",{staticClass:"strut bottom",staticStyle:{height:"0.43056em","vertical-align":"0em"}}),a("span",{staticClass:"base textstyle uncramped"},[a("span",{staticClass:"mord mathit"},[t._v("u")])])])]),t._v("，如果对于所有的快递点v(v≠u)，快递员都可以从"),a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",[a("semantics",[a("mrow",[a("mi",[t._v("u")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("u")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"strut",staticStyle:{height:"0.43056em"}}),a("span",{staticClass:"strut bottom",staticStyle:{height:"0.43056em","vertical-align":"0em"}}),a("span",{staticClass:"base textstyle uncramped"},[a("span",{staticClass:"mord mathit"},[t._v("u")])])])]),t._v("走到"),a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",[a("semantics",[a("mrow",[a("mi",[t._v("v")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("v")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"strut",staticStyle:{height:"0.43056em"}}),a("span",{staticClass:"strut bottom",staticStyle:{height:"0.43056em","vertical-align":"0em"}}),a("span",{staticClass:"base textstyle uncramped"},[a("span",{staticClass:"mord mathit",staticStyle:{"margin-right":"0.03588em"}},[t._v("v")])])])]),t._v("，或者从"),a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",[a("semantics",[a("mrow",[a("mi",[t._v("v")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("v")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"strut",staticStyle:{height:"0.43056em"}}),a("span",{staticClass:"strut bottom",staticStyle:{height:"0.43056em","vertical-align":"0em"}}),a("span",{staticClass:"base textstyle uncramped"},[a("span",{staticClass:"mord mathit",staticStyle:{"margin-right":"0.03588em"}},[t._v("v")])])])]),t._v("走到"),a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",[a("semantics",[a("mrow",[a("mi",[t._v("u")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("u")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"strut",staticStyle:{height:"0.43056em"}}),a("span",{staticClass:"strut bottom",staticStyle:{height:"0.43056em","vertical-align":"0em"}}),a("span",{staticClass:"base textstyle uncramped"},[a("span",{staticClass:"mord mathit"},[t._v("u")])])])]),t._v("，那么则评定站点"),a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",[a("semantics",[a("mrow",[a("mi",[t._v("u")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("u")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"strut",staticStyle:{height:"0.43056em"}}),a("span",{staticClass:"strut bottom",staticStyle:{height:"0.43056em","vertical-align":"0em"}}),a("span",{staticClass:"base textstyle uncramped"},[a("span",{staticClass:"mord mathit"},[t._v("u")])])])]),t._v("为超级快递点。请你帮忙计算，一共有多少个超级快递点。")]),t._v(" "),a("h2",{attrs:{id:"输入描述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#输入描述"}},[t._v("#")]),t._v(" 输入描述")]),t._v(" "),a("blockquote",[a("p",[t._v("第一行 2个数字n(2≤n≤3*10^5)，")]),t._v(" "),a("p",[t._v("m(1≤m<3*10^5);n为快递点个数，m为单向车道个数")]),t._v(" "),a("p",[t._v("接下来的"),a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",[a("semantics",[a("mrow",[a("mi",[t._v("m")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("m")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"strut",staticStyle:{height:"0.43056em"}}),a("span",{staticClass:"strut bottom",staticStyle:{height:"0.43056em","vertical-align":"0em"}}),a("span",{staticClass:"base textstyle uncramped"},[a("span",{staticClass:"mord mathit"},[t._v("m")])])])]),t._v("行每行两个数字u,v(1≤u,v≤n,u≠v)，表示有一条站点"),a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",[a("semantics",[a("mrow",[a("mi",[t._v("u")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("u")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"strut",staticStyle:{height:"0.43056em"}}),a("span",{staticClass:"strut bottom",staticStyle:{height:"0.43056em","vertical-align":"0em"}}),a("span",{staticClass:"base textstyle uncramped"},[a("span",{staticClass:"mord mathit"},[t._v("u")])])])]),t._v("指向"),a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",[a("semantics",[a("mrow",[a("mi",[t._v("v")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("v")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"strut",staticStyle:{height:"0.43056em"}}),a("span",{staticClass:"strut bottom",staticStyle:{height:"0.43056em","vertical-align":"0em"}}),a("span",{staticClass:"base textstyle uncramped"},[a("span",{staticClass:"mord mathit",staticStyle:{"margin-right":"0.03588em"}},[t._v("v")])])])]),t._v("的单向车道。")])]),t._v(" "),a("h2",{attrs:{id:"输出描述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#输出描述"}},[t._v("#")]),t._v(" 输出描述")]),t._v(" "),a("blockquote",[a("p",[t._v("请输出1个数字，表示超级快递点的个数。")])]),t._v(" "),a("h2",{attrs:{id:"样例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#样例"}},[t._v("#")]),t._v(" 样例")]),t._v(" "),a("p",[a("strong",[t._v("输入")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("7 7\n1 2\n2 3\n3 4\n4 7\n2 5\n5 4\n6 4\n")])])]),a("p",[a("strong",[t._v("输出")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("2\n")])])]),a("p",[a("strong",[t._v("说明")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("快递点4可以到达 4，7，可以从1，2，3，5，6到达，评为超级快递点\n快递点7可以到达7，可以从1，2，3，4，5，6到达，评为超级快递点\n")])])]),a("p",[a("img",{attrs:{src:"/split.png",alt:"split"}})]),t._v(" "),a("h2",{attrs:{id:"题目思路"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#题目思路"}},[t._v("#")]),t._v(" 题目思路")]),t._v(" "),a("p",[t._v("本题难度非常大，需要对图论有较深的理解，不建议初学者尝试。你需要提前了解"),a("a",{attrs:{href:"https://oi-wiki.org/graph/topo/",target:"_blank",rel:"noopener noreferrer"}},[t._v("拓扑排序"),a("OutboundLink")],1),t._v("以及"),a("a",{attrs:{href:"https://oi-wiki.org/graph/topo/#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E5%92%8C-aoe-%E7%BD%91",target:"_blank",rel:"noopener noreferrer"}},[t._v("关键路径"),a("OutboundLink")],1),t._v("的相关知识。")]),t._v(" "),a("p",[t._v("我们拓扑排序后可以得到一个序列，并通过这个序列的我们可以计算得到每个点的最早开始时间和最晚开始时间。一个点的最早开始时间和最晚开始时间相等时，我们称这个点是关键路径上的点，关键路径同时也是最长的路径。")]),t._v(" "),a("p",[t._v("对于一个超级快递点y，假设其在拓扑排序中的序列的位置是x，那么"),a("code",[t._v("[1,x-1]")]),t._v("对应的点都可以到达y，且y可以到达所有"),a("code",[t._v("[x + 1,n]")]),t._v("的点。")]),t._v(" "),a("p",[t._v("超级快递点有一个性质，那就是它肯定是关键路径上的点，我们可以假设前面属于关键路径上的点形成一条链，后面属于关键路径上的点形成一条链，那么由于关键路径是最长的，所以经过点y肯定比不经过点y更长。\n但是这只是一个必要条件，还存在以下的平行的特殊情况：")]),t._v(" "),a("ol",[a("li",[t._v("点y和点z平行，即"),a("code",[t._v("1 -> y -> 2")]),t._v("，"),a("code",[t._v("1 -> z -> 2")]),t._v("，y和z完全平行，此时y不可以到达z，z也不可以到达y，但是它们确实满足最早开始时间和最晚开始时间相等，这种情况下的y和z的最早开始时间也相等，我们可以根据最晚开始时间排序后相邻且相等的时间来排除。")]),t._v(" "),a("li",[t._v("点y和点z平行，但是是两条路径平行，比如 "),a("code",[t._v("1 -> 2 -> y -> 6, 3 -> z -> 5")]),t._v("，此时y在关键路径上，但是它不是超级快递点，此时z和它平行，此时z和y的最晚开始时间相同，但是z的最早时间却比y更早，那就说明存在一条比关键路径更短的平行路径，且y就在平行路径中。")])]),t._v(" "),a("p",[t._v("所以对于关键路径上的点y，如果有点和它的最早开始时间和最晚开始时间都是相同的，又或者说出现了最晚开始时间大于等该点的点z，z的最早开始时间却小于等于点y的最早开始时间，那这个点就不是超级快递点。")]),t._v(" "),a("p",[t._v("平行路径上的点y只要不平行于其它节点，那从拓扑排序中点y前面的点肯定可以到达它，我们通过反证法证明，如果前面有一个点z到达不了点y，说明z可以跨过y到达后面的终点，这就是另外一个平行点，这与y没有平行点冲突，后面的点可以到达y也是同样的道理。")]),t._v(" "),a("p",[t._v("所以我们通过最晚完成时间，最早完成时间进行两个关键字排序，枚举关键路径上的每一个点，当这个点不存在平行点时，就将其加入到答案中。")]),t._v(" "),a("p",[t._v("时间复杂度"),a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",[a("semantics",[a("mrow",[a("mi",[t._v("O")]),a("mo",[t._v("(")]),a("mi",[t._v("n")]),a("mi",[t._v("l")]),a("mi",[t._v("o")]),a("mi",[t._v("g")]),a("mi",[t._v("n")]),a("mo",[t._v(")")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("O(nlogn)")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"strut",staticStyle:{height:"0.75em"}}),a("span",{staticClass:"strut bottom",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),a("span",{staticClass:"base textstyle uncramped"},[a("span",{staticClass:"mord mathit",staticStyle:{"margin-right":"0.02778em"}},[t._v("O")]),a("span",{staticClass:"mopen"},[t._v("(")]),a("span",{staticClass:"mord mathit"},[t._v("n")]),a("span",{staticClass:"mord mathit",staticStyle:{"margin-right":"0.01968em"}},[t._v("l")]),a("span",{staticClass:"mord mathit"},[t._v("o")]),a("span",{staticClass:"mord mathit",staticStyle:{"margin-right":"0.03588em"}},[t._v("g")]),a("span",{staticClass:"mord mathit"},[t._v("n")]),a("span",{staticClass:"mclose"},[t._v(")")])])])])]),t._v(" "),a("h2",{attrs:{id:"代码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#代码"}},[t._v("#")]),t._v(" 代码")]),t._v(" "),a("p",[a("strong",[t._v("C++")])]),t._v(" "),a("div",{staticClass:"language-c++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = int64_t;\nusing u64 = uint64_t;\n\n\nvoid solve() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> adj(n);\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--, v--;\n        adj[u].push_back(v);\n    }\n    // 拓扑排序\n    vector<int> ind(n, 0);\n    for (int i = 0; i < n; i++) {\n        for (int v : adj[i]) ind[v]++;\n    }\n    queue<int> q;\n    for (int i = 0; i < n; i++) {\n        if (!ind[i]) q.push(i);\n    }\n    vector<int> ord;\n    for (int i = 0; i < n; i++) {\n        int u = q.front(); q.pop();\n        ord.push_back(u);\n        for (int v : adj[u]) {\n            if (--ind[v] == 0) {\n                q.push(v);\n            }\n        }\n    }\n    // 计算最早开始时间和最晚开始时间\n    vector<int> min_time(n, 0), max_time(n, 0);\n    int tot = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j : adj[ord[i]]) {\n            min_time[j] = max(min_time[j], min_time[ord[i]] + 1);\n            tot = max(tot, min_time[j]);\n        }\n    }\n    max_time = vector<int>(n, tot);\n    for (int i = n - 1; i >= 0; i--) {\n        for (int j : adj[ord[i]]) {\n            max_time[ord[i]] = min(max_time[ord[i]], max_time[j] - 1);\n        }\n    }\n    int ans = 0;\n    vector<int> idx(n);\n    iota(idx.begin(), idx.end(), 0);\n    // 根据最晚开始时间排序\n    sort(idx.begin(), idx.end(), [&](int x, int y) {\n    \tif (max_time[x] != max_time[y]) return max_time[x] > max_time[y];\n    \treturn min_time[x] < min_time[y];\n    });\n    for (int i = 0, l = 0x3f3f3f3f; i < n; i++) {\n    \tint j = idx[i];\n    \t// 超级快递点必定满足最早开始时间和最晚开始时间相同\n        if (min_time[j] != max_time[j]) {\n        \tl = min(min_time[j], l);\n        \tcontinue;\n        }\n        // 除去平行链路情况\n        if (l <= min_time[j]) continue; // 题解中的第二种情况\n        l = min_time[j];\n        // 题解中的第一种情况\n        if (i + 1 < n && max_time[j] == max_time[idx[i + 1]] && min_time[j] == min_time[idx[i + 1]]) continue;\n        ++ ans;\n    }\n    cout << ans << endl;\n}\n\nint main(void) {\n    ios::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n    int t = 1;\n    while (t--) {\n    \tsolve(); \n\t}\n}\n")])])]),a("p",[a("strong",[t._v("会员可通过查看《已通过》的提交记录来查看其他语言哦~")])])])}),[],!1,null,null,null);a.default=n.exports}}]);